<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPO Vaja 3 - Directory Operations</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e27;
            --bg-card: #151933;
            --text-primary: #e4e4e7;
            --text-secondary: #a1a1aa;
            --accent-purple: #b794f6;
            --accent-blue: #63b3ed;
            --accent-green: #68d391;
            --accent-orange: #f6ad55;
            --accent-red: #fc8181;
            --accent-yellow: #fbd38d;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 50px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(183, 148, 246, 0.1), rgba(99, 179, 237, 0.1));
            border-radius: 20px;
            border: 2px solid var(--accent-purple);
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.2em;
        }

        .program-section {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            border: 2px solid var(--accent-purple);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .program-title {
            font-size: 2.2em;
            color: var(--accent-blue);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .task-box {
            background: rgba(104, 211, 145, 0.1);
            border-left: 5px solid var(--accent-green);
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }

        .task-box h3 {
            color: var(--accent-green);
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .task-box ul {
            margin-left: 25px;
            color: var(--text-secondary);
        }

        .task-box li {
            margin-bottom: 10px;
            line-height: 1.8;
        }

        .code-block {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid var(--accent-purple);
            overflow-x: auto;
            position: relative;
        }

        .code-block h4 {
            color: var(--accent-purple);
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .code-block pre {
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            overflow-x: auto;
            margin: 0;
        }

        .code-block pre code {
            font-family: 'Courier New', monospace;
        }

        .explanation {
            background: rgba(183, 148, 246, 0.1);
            border-left: 5px solid var(--accent-purple);
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
        }

        .explanation h4 {
            color: var(--accent-purple);
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .explanation h5 {
            color: var(--accent-orange);
            margin: 25px 0 15px 0;
            font-size: 1.3em;
        }

        .explanation p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.9;
        }

        .explanation strong {
            color: var(--accent-orange);
        }

        .explanation ul, .explanation ol {
            margin: 15px 0 15px 30px;
        }

        .explanation li {
            margin-bottom: 12px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .code-snippet {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            color: #d4d4d4;
            border: 1px solid var(--accent-blue);
            overflow-x: auto;
        }

        .highlight-box {
            background: rgba(246, 173, 85, 0.1);
            border: 2px solid var(--accent-orange);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .highlight-box h5 {
            color: var(--accent-orange);
            margin-bottom: 12px;
        }

        .warning-box {
            background: rgba(252, 129, 129, 0.1);
            border: 2px solid var(--accent-red);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .warning-box h5 {
            color: var(--accent-red);
            margin-bottom: 12px;
        }

        .inline-code {
            background: rgba(183, 148, 246, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: var(--accent-blue);
            font-size: 0.9em;
        }

        .diagram {
            text-align: center;
            padding: 20px;
            background: #1e1e1e;
            border-radius: 10px;
            margin: 20px 0;
            color: var(--accent-green);
            font-family: 'Courier New', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.8;
        }

        .flow-box {
            background: rgba(251, 211, 141, 0.1);
            border: 2px solid var(--accent-yellow);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .flow-box h5 {
            color: var(--accent-yellow);
            margin-bottom: 12px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }

            .program-title {
                font-size: 1.8em;
            }

            .container {
                padding: 20px 10px;
            }

            .program-section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="background-animation"></div>

    <div class="docs-container">
        <a href="spo-docs-index.html" class="back-link">‚Üê Back to SPO Index</a>

        <div class="docs-header">
            <h1>üìÅ Vaja 3: Directory Operations and Path Resolution</h1>
            <p class="subtitle">Working with directories, sorting, and path resolution</p>
        </div>

        <!-- lst.c -->
        <div class="file-card">
            <div class="file-name">üìÑ lst.c</div>

            <div class="task-description">
                <h3>Naloga 1: LST - Sortiranje datotek po ƒçasu modifikacije</h3>
                <ul>
                    <li>Napi≈°ite v C-ju program lst, ki izvede poenostavljeno verzijo ukaza ls ‚Äìt</li>
                    <li>Izpi≈°e direktorijske vnose (datoteke in poddirektorije) v vrstnem redu od najstarej≈°ih do najmlaj≈°ih (glede na ƒças modifikacije)</li>
                    <li>Podpira obratni vrstni red (kot ls ‚Äìtr, kjer r pomeni reversed order)</li>
                    <li>Za sortiranje lahko uporabite funkcijo qsort iz knji≈ænice stdlib</li>
                </ul>
            </div>

            <div class="usage-example">
                <strong>Usage Examples:</strong><br>
                $ ./lst           # Izpi≈°e datoteke od najstarej≈°ih do najnovej≈°ih<br>
                $ ./lst -r        # Izpi≈°e datoteke od najnovej≈°ih do najstarej≈°ih
            </div>

            <div class="code-display">
                <h4>Source Code:</h4>
                <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;time.h&gt;

// Struktura za shranjevanje informacij o datoteki
typedef struct {
    char name[256];
    time_t mtime;
} FileEntry;

// Funkcija za primerjavo ‚Äî od najstarej≈°ih do najnovej≈°ih
int compare_asc(const void *a, const void *b) {
    FileEntry *fa = (FileEntry *)a;
    FileEntry *fb = (FileEntry *)b;
    if (fa-&gt;mtime &lt; fb-&gt;mtime) return -1;
    if (fa-&gt;mtime &gt; fb-&gt;mtime) return 1;
    return 0;
}

// Funkcija za primerjavo ‚Äî od najnovej≈°ih do najstarej≈°ih
int compare_desc(const void *a, const void *b) {
    return compare_asc(b, a);
}

int main(int argc, char *argv[]) {
    int reverse = 0;
    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], "-r") == 0) {
        reverse = 1;
    }

    DIR *dir;
    struct dirent *entry;
    struct stat fileStat;
    FileEntry *files = NULL;
    int count = 0;

    dir = opendir(".");
    if (dir == NULL) {
        perror("Napaka pri odpiranju direktorija");
        return 1;
    }

    // Preberi vse datoteke v trenutnem direktoriju
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry-&gt;d_name, ".") == 0 || strcmp(entry-&gt;d_name, "..") == 0)
            continue;

        if (stat(entry-&gt;d_name, &amp;fileStat) == -1) {
            perror("stat");
            continue;
        }

        files = realloc(files, (count + 1) * sizeof(FileEntry));
        if (files == NULL) {
            perror("Napaka pri alokaciji pomnilnika");
            closedir(dir);
            return 1;
        }

        strncpy(files[count].name, entry-&gt;d_name, sizeof(files[count].name));
        files[count].name[sizeof(files[count].name) - 1] = '\0';
        files[count].mtime = fileStat.st_mtime;
        count++;
    }
    closedir(dir);

    // Sortiraj po ƒçasu modifikacije
    qsort(files, count, sizeof(FileEntry), reverse ? compare_desc : compare_asc);

    // Izpi≈°i rezultate
    for (int i = 0; i &lt; count; i++) {
        struct tm *timeinfo = localtime(&amp;files[i].mtime);
        char timebuf[64];
        strftime(timebuf, sizeof(timebuf), "%Y-%m-%d %H:%M:%S", timeinfo);
        printf("%-30s  %s\n", files[i].name, timebuf);
    }

    free(files);
    return 0;
}</code></pre>
            </div>

            <div class="explanation-section">
                <h4>üìñ Detailed Code Explanation</h4>

                <div class="explanation-block">
                    <h5>üìö 1. Struktura FileEntry in primerjalne funkcije</h5>
                    <div class="code-snippet">typedef struct {
    char name[256];
    time_t mtime;
} FileEntry;

int compare_asc(const void *a, const void *b) {
    FileEntry *fa = (FileEntry *)a;
    FileEntry *fb = (FileEntry *)b;
    if (fa-&gt;mtime &lt; fb-&gt;mtime) return -1;
    if (fa-&gt;mtime &gt; fb-&gt;mtime) return 1;
    return 0;
}</div>
                    <div class="description">
                        <strong>FileEntry struktura</strong> shranjuje ime datoteke in ƒças zadnje modifikacije.<br><br>
                        <strong>time_t mtime</strong>: Unix timestamp (≈°tevilo sekund od 1.1.1970) zadnje spremembe datoteke.<br><br>
                        <strong>compare_asc() funkcija</strong>: Primerja dve datoteki po ƒçasu modifikacije.<br>
                        <ul>
                            <li>Vrne <strong>-1</strong> ƒçe je prva datoteka starej≈°a (mtime manj≈°i)</li>
                            <li>Vrne <strong>1</strong> ƒçe je prva datoteka novej≈°a (mtime veƒçji)</li>
                            <li>Vrne <strong>0</strong> ƒçe sta enaki</li>
                        </ul>
                        <strong>compare_desc() funkcija</strong>: Obrne vrstni red s klicem compare_asc(b, a) namesto compare_asc(a, b).
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üìÇ 2. Branje direktorija z opendir() in readdir()</h5>
                    <div class="code-snippet">DIR *dir = opendir(".");
struct dirent *entry;

while ((entry = readdir(dir)) != NULL) {
    if (strcmp(entry-&gt;d_name, ".") == 0 || strcmp(entry-&gt;d_name, "..") == 0)
        continue;
    // ...
}</div>
                    <div class="description">
                        <strong>opendir(".")</strong>: Odpre trenutni direktorij za branje.<br>
                        ‚Üí Vrne kazalec tipa DIR*, ki ga uporabljamo za iteracijo.<br><br>
                        <strong>readdir(dir)</strong>: Prebere naslednji vnos v direktoriju.<br>
                        ‚Üí Vrne kazalec na strukturo dirent, ki vsebuje informacije o vnosu.<br>
                        ‚Üí Vrne NULL, ko ni veƒç vnosov.<br><br>
                        <strong>entry-&gt;d_name</strong>: Ime datoteke ali poddirektorija.<br><br>
                        <strong>Preskakovanje "." in ".."</strong>: Te vnose preskoƒçimo, ker predstavljajo trenutni in nadrejeni direktorij.
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üìä 3. Pridobivanje metapodatkov s stat()</h5>
                    <div class="code-snippet">struct stat fileStat;
if (stat(entry-&gt;d_name, &amp;fileStat) == -1) {
    perror("stat");
    continue;
}

files[count].mtime = fileStat.st_mtime;</div>
                    <div class="description">
                        <strong>stat()</strong>: Prebere metapodatke datoteke (velikost, dovoljenja, ƒçasi, itd.).<br><br>
                        <strong>fileStat.st_mtime</strong>: ƒåas zadnje modifikacije datoteke (modification time).<br>
                        ‚Üí Tip time_t - ≈°tevilo sekund od Unix epoch (1.1.1970).<br><br>
                        <strong>Drugi uporabni ƒçasi v stat:</strong>
                        <ul>
                            <li><strong>st_atime</strong>: ƒåas zadnjega dostopa (access time)</li>
                            <li><strong>st_ctime</strong>: ƒåas zadnje spremembe metapodatkov (change time)</li>
                        </ul>
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üîÑ 4. Dinamiƒçna alokacija in rast polja</h5>
                    <div class="code-snippet">files = realloc(files, (count + 1) * sizeof(FileEntry));
if (files == NULL) {
    perror("Napaka pri alokaciji pomnilnika");
    closedir(dir);
    return 1;
}</div>
                    <div class="description">
                        <strong>realloc()</strong>: Spremeni velikost ≈æe alociranega pomnilnika.<br><br>
                        <strong>Zakaj realloc?</strong>
                        <ul>
                            <li>Na zaƒçetku ne vemo, koliko datotek je v direktoriju</li>
                            <li>Vsako iteracijo poveƒçamo polje za en FileEntry</li>
                            <li>realloc posku≈°a raz≈°iriti obstojeƒçi blok, ƒçe je mo≈æno</li>
                            <li>ƒåe ne more, premakne podatke na novo lokacijo</li>
                        </ul>
                        <strong>Pomembno</strong>: Vedno preverimo, ƒçe je realloc uspel (ƒçe ni vrnil NULL).
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üìê 5. Sortiranje s qsort()</h5>
                    <div class="code-snippet">qsort(files, count, sizeof(FileEntry),
      reverse ? compare_desc : compare_asc);</div>
                    <div class="description">
                        <strong>qsort()</strong>: Standardna C funkcija za sortiranje (quick sort algoritem).<br><br>
                        <strong>Parametri:</strong>
                        <ul>
                            <li><strong>files</strong>: Kazalec na polje, ki ga sortiramo</li>
                            <li><strong>count</strong>: ≈†tevilo elementov v polju</li>
                            <li><strong>sizeof(FileEntry)</strong>: Velikost vsakega elementa v bajtih</li>
                            <li><strong>compare_asc/compare_desc</strong>: Kazalec na primerjalno funkcijo</li>
                        </ul>
                        <strong>Ternarni operator (?:)</strong>: Izbere compare_desc ƒçe je reverse=1, sicer compare_asc.
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üïê 6. Formatiranje ƒçasa za izpis</h5>
                    <div class="code-snippet">struct tm *timeinfo = localtime(&amp;files[i].mtime);
char timebuf[64];
strftime(timebuf, sizeof(timebuf), "%Y-%m-%d %H:%M:%S", timeinfo);
printf("%-30s  %s\n", files[i].name, timebuf);</div>
                    <div class="description">
                        <strong>localtime()</strong>: Pretvori Unix timestamp (time_t) v strukturo tm z lokalnim ƒçasom.<br><br>
                        <strong>struct tm</strong>: Vsebuje polja year, month, day, hour, minute, second.<br><br>
                        <strong>strftime()</strong>: Formatira ƒças v berljiv niz.<br>
                        ‚Üí <strong>%Y-%m-%d %H:%M:%S</strong> format: "2026-01-11 15:30:45"<br><br>
                        <strong>printf("%-30s")</strong>: Izpi≈°e niz poravnan na levo, ≈°irina 30 znakov.
                    </div>
                </div>
            </div>

            <div class="key-concepts">
                <h4>Key Concepts:</h4>
                <ul>
                    <li>Branje direktorijev z opendir() in readdir()</li>
                    <li>Dinamiƒçna alokacija pomnilnika z realloc()</li>
                    <li>Sortiranje s qsort() in primerjalne funkcije</li>
                    <li>Delo s ƒçasom (time_t, struct tm, localtime, strftime)</li>
                    <li>Struktura dirent in stat za metapodatke</li>
                </ul>
            </div>
        </div>

        <!-- pwd1.c -->
        <div class="file-card">
            <div class="file-name">üìÑ pwd1.c</div>

            <div class="task-description">
                <h3>Naloga 2: PWD - Poenostavljena verzija getcwd</h3>
                <ul>
                    <li>Napi≈°ite v C-ju poenostavljeno verzijo funkcije getcwd, ki sestavi absolutno pot do trenutnega direktorija</li>
                    <li>Napi≈°ite program pwd1, ki kliƒçe to funkcijo in izpi≈°e pot, podobno kot ukaz pwd</li>
                    <li>Odprete star≈°evski imenik in v njem pregledujete vnose ‚Äì ko najdete tistega z enako inode-≈°tevilko</li>
                    <li>Premikajte se preko star≈°ev s pomoƒçjo chdir(".."), dokler ne pridete do root imenika</li>
                    <li>V korenskem imeniku je inode-≈°tevilka star≈°a enaka njegovi</li>
                </ul>
            </div>

            <div class="usage-example">
                <strong>Usage Example:</strong><br>
                $ ./pwd1<br>
                /home/spo/SPO
            </div>

            <div class="code-display">
                <h4>Source Code:</h4>
                <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

#define MAX_PATH 4096

// Funkcija, ki poenostavljeno implementira getcwd()
char *my_getcwd(char *buf, size_t size) {
    struct stat current_stat, parent_stat;
    char *path = malloc(MAX_PATH);
    if (!path) {
        perror("malloc");
        return NULL;
    }
    path[0] = '\0'; // zaƒçnemo z prazno potjo

    while (1) {
        // Preberi podatke o trenutnem in star≈°evskem direktoriju
        if (stat(".", &amp;current_stat) == -1) {
            perror("stat .");
            free(path);
            return NULL;
        }

        if (stat("..", &amp;parent_stat) == -1) {
            perror("stat ..");
            free(path);
            return NULL;
        }

        // ƒåe imata trenutni in star≈°evski isti inode, smo v korenskem direktoriju
        if (current_stat.st_ino == parent_stat.st_ino &amp;&amp;
            current_stat.st_dev == parent_stat.st_dev) {
            // ƒåe smo v korenu, dodamo zaƒçetni '/'
            if (strlen(path) == 0)
                strcpy(path, "/");
            break;
        }

        // Premaknemo se v nadrejeni direktorij
        if (chdir("..") == -1) {
            perror("chdir ..");
            free(path);
            return NULL;
        }

        // Poi≈°ƒçemo ime trenutnega direktorija v nadrejenem direktoriju
        DIR *dir = opendir(".");
        if (!dir) {
            perror("opendir");
            free(path);
            return NULL;
        }

        struct dirent *entry;
        char dirname[256];
        dirname[0] = '\0';

        while ((entry = readdir(dir)) != NULL) {
            struct stat entry_stat;
            if (stat(entry-&gt;d_name, &amp;entry_stat) == -1)
                continue;

            if (entry_stat.st_ino == current_stat.st_ino &amp;&amp;
                entry_stat.st_dev == current_stat.st_dev) {
                strncpy(dirname, entry-&gt;d_name, sizeof(dirname));
                dirname[sizeof(dirname) - 1] = '\0';
                break;
            }
        }
        closedir(dir);

        // Sestavimo pot: dodamo "/ime" pred obstojeƒço pot
        char temp[MAX_PATH];
        snprintf(temp, sizeof(temp), "/%s%s", dirname, path);
        strncpy(path, temp, MAX_PATH);
        path[MAX_PATH - 1] = '\0';
    }

    // Kopiramo v uporabnikov buffer (ƒçe obstaja)
    if (buf != NULL &amp;&amp; size &gt; 0) {
        strncpy(buf, path, size);
        buf[size - 1] = '\0';
        free(path);
        return buf;
    }

    return path; // vrnemo dinamiƒçno alociran niz
}

int main() {
    char buffer[MAX_PATH];

    if (my_getcwd(buffer, sizeof(buffer)) == NULL) {
        fprintf(stderr, "Napaka pri pridobivanju poti.\n");
        return 1;
    }

    printf("%s\n", buffer);
    return 0;
}</code></pre>
            </div>

            <div class="explanation-section">
                <h4>üìñ Detailed Code Explanation</h4>

                <div class="explanation-block">
                    <h5>üîç 1. Preverjanje korenskega direktorija</h5>
                    <div class="code-snippet">if (current_stat.st_ino == parent_stat.st_ino &amp;&amp;
    current_stat.st_dev == parent_stat.st_dev) {
    if (strlen(path) == 0)
        strcpy(path, "/");
    break;
}</div>
                    <div class="description">
                        <strong>Kako prepoznamo root direktorij?</strong><br>
                        V Linux datoteƒçnem sistemu ima root "/" edinstven inode, kjer je njegov star≈° on sam.<br><br>
                        <strong>st_ino</strong>: Inode ≈°tevilka (unique identifier datoteke/direktorija v datoteƒçnem sistemu)<br>
                        <strong>st_dev</strong>: Device ID (identifier naprave/particije)<br><br>
                        <strong>Pogoj</strong>: ƒåe imata "." in ".." enako inode ≈°tevilko IN device ID, smo v korenu.<br><br>
                        <strong>Zakaj oba?</strong> st_dev je pomemben, ƒçe je sistem montiran na veƒç particij.
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>‚¨ÜÔ∏è 2. Premikanje navzgor po drevesu direktorijev</h5>
                    <div class="code-snippet">if (chdir("..") == -1) {
    perror("chdir ..");
    free(path);
    return NULL;
}</div>
                    <div class="description">
                        <strong>chdir("..")</strong>: Sistemski klic, ki spremeni trenutni delovni direktorij procesa.<br><br>
                        <strong>".."</strong>: Simboliƒçna povezava na nadrejeni (star≈°evski) direktorij.<br><br>
                        <strong>Pomembno</strong>: Po chdir("..")  smo se premaknili en nivo vi≈°je v hierarhiji.<br>
                        ‚Üí Prej: /home/spo/SPO<br>
                        ‚Üí Po chdir(".."): /home/spo
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üîé 3. Iskanje imena direktorija po inode ≈°tevilki</h5>
                    <div class="code-snippet">while ((entry = readdir(dir)) != NULL) {
    struct stat entry_stat;
    if (stat(entry-&gt;d_name, &amp;entry_stat) == -1)
        continue;

    if (entry_stat.st_ino == current_stat.st_ino &amp;&amp;
        entry_stat.st_dev == current_stat.st_dev) {
        strncpy(dirname, entry-&gt;d_name, sizeof(dirname));
        break;
    }
}</div>
                    <div class="description">
                        <strong>Algoritem:</strong><br>
                        1. Shranimo inode trenutnega direktorija (current_stat.st_ino)<br>
                        2. Premaknemo se v star≈°a z chdir("..")<br>
                        3. Preberemo vse vnose v star≈°evskem direktoriju<br>
                        4. Za vsak vnos preverimo, ƒçe se inode ujema s shranjenim<br>
                        5. Ko najdemo ujemanje, smo na≈°li ime direktorija<br><br>
                        <strong>Primer:</strong><br>
                        ƒåe smo bili v /home/spo/SPO:<br>
                        ‚Üí inode direktorija "SPO" je npr. 12345<br>
                        ‚Üí Po chdir("..") smo v /home/spo<br>
                        ‚Üí Pregledamo vnose: spo, Documents, ...<br>
                        ‚Üí Vnos z inode 12345 je "SPO" - to je na≈°e ime!
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üîó 4. Gradnja poti v obratnem vrstnem redu</h5>
                    <div class="code-snippet">char temp[MAX_PATH];
snprintf(temp, sizeof(temp), "/%s%s", dirname, path);
strncpy(path, temp, MAX_PATH);
path[MAX_PATH - 1] = '\0';</div>
                    <div class="description">
                        <strong>Zakaj obratni vrstni red?</strong><br>
                        Potujemo od trenutnega direktorija navzgor (SPO ‚Üí spo ‚Üí home ‚Üí /), zato moramo imena dodajati na zaƒçetek.<br><br>
                        <strong>Postopek gradnje poti:</strong>
                        <ul>
                            <li><strong>Zaƒçetek:</strong> path = "" (prazen)</li>
                            <li><strong>1. iteracija:</strong> dirname="SPO" ‚Üí path="/SPO"</li>
                            <li><strong>2. iteracija:</strong> dirname="spo" ‚Üí path="/spo/SPO"</li>
                            <li><strong>3. iteracija:</strong> dirname="home" ‚Üí path="/home/spo/SPO"</li>
                            <li><strong>4. iteracija:</strong> Dose≈æemo root, konƒçamo</li>
                        </ul>
                        <strong>snprintf()</strong>: Varno formatiranje niza z omejitvijo velikosti (prepreƒçuje buffer overflow).
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üíæ 5. Vraƒçanje rezultata</h5>
                    <div class="code-snippet">if (buf != NULL &amp;&amp; size &gt; 0) {
    strncpy(buf, path, size);
    buf[size - 1] = '\0';
    free(path);
    return buf;
}
return path;</div>
                    <div class="description">
                        <strong>Dve mo≈ænosti za vraƒçanje:</strong><br><br>
                        <strong>1. ƒåe uporabnik poda buffer:</strong>
                        <ul>
                            <li>Kopiramo pot v uporabnikov buffer</li>
                            <li>Sprostimo zaƒçasni dinamiƒçni path</li>
                            <li>Vrnemo kazalec na uporabnikov buffer</li>
                        </ul>
                        <strong>2. ƒåe buffer je NULL:</strong>
                        <ul>
                            <li>Vrnemo dinamiƒçno alociran path</li>
                            <li>Uporabnik je odgovoren za free()</li>
                        </ul>
                        <strong>Kompatibilnost z getcwd()</strong>: Prava getcwd() deluje enako - podpora za oba naƒçina.
                    </div>
                </div>
            </div>

            <div class="key-concepts">
                <h4>Key Concepts:</h4>
                <ul>
                    <li>Inode ≈°tevilke in njihova uporaba za identifikacijo datotek</li>
                    <li>chdir() za spreminjanje trenutnega direktorija</li>
                    <li>Gradnja poti v obratnem vrstnem redu</li>
                    <li>Preverjanje korenskega direktorija (st_ino == parent st_ino)</li>
                    <li>Iskanje imen po inode ≈°tevilkah</li>
                    <li>Dinamiƒçna alokacija in upravljanje pomnilnika</li>
                </ul>
            </div>
        </div>

    </div>

</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
</html>

