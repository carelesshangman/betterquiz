<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPO Vaja 10 - Paralelni TCP StreÅ¾nik</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e27;
            --bg-card: #151933;
            --text-primary: #e4e4e7;
            --text-secondary: #a1a1aa;
            --accent-purple: #b794f6;
            --accent-blue: #63b3ed;
            --accent-green: #68d391;
            --accent-orange: #f6ad55;
            --accent-red: #fc8181;
            --accent-yellow: #fbd38d;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 50px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(183, 148, 246, 0.1), rgba(99, 179, 237, 0.1));
            border-radius: 20px;
            border: 2px solid var(--accent-purple);
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.2em;
        }

        .program-section {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            border: 2px solid var(--accent-purple);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .program-title {
            font-size: 2.2em;
            color: var(--accent-blue);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .task-box {
            background: rgba(104, 211, 145, 0.1);
            border-left: 5px solid var(--accent-green);
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }

        .task-box h3 {
            color: var(--accent-green);
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .task-box ul {
            margin-left: 25px;
            color: var(--text-secondary);
        }

        .task-box li {
            margin: 8px 0;
        }

        .code-block {
            margin: 30px 0;
        }

        .code-block h4 {
            color: var(--accent-purple);
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .code-block pre {
            background: #1e1e1e !important;
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
            border: 2px solid var(--accent-purple);
        }

        .explanation {
            margin: 30px 0;
        }

        .explanation h4 {
            color: var(--accent-orange);
            margin: 25px 0 15px 0;
            font-size: 1.5em;
        }

        .explanation h5 {
            color: var(--accent-blue);
            margin: 20px 0 12px 0;
            font-size: 1.2em;
        }

        .explanation p {
            color: var(--text-secondary);
            margin: 12px 0;
            line-height: 1.8;
        }

        .explanation ul {
            margin: 12px 0 12px 25px;
            color: var(--text-secondary);
        }

        .explanation li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .code-snippet {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            color: var(--accent-green);
            margin: 15px 0;
            border-left: 4px solid var(--accent-purple);
            overflow-x: auto;
        }

        .line-explanation {
            background: rgba(99, 179, 237, 0.1);
            border-left: 4px solid var(--accent-blue);
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
        }

        .line-explanation .line-num {
            color: var(--accent-purple);
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .line-explanation .code {
            background: #1e1e1e;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            color: var(--accent-green);
            margin: 8px 0;
            display: block;
        }

        .line-explanation .desc {
            color: var(--text-secondary);
            margin-top: 8px;
            line-height: 1.6;
        }

        .highlight-box {
            background: rgba(99, 179, 237, 0.1);
            border: 2px solid var(--accent-blue);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .highlight-box h5 {
            color: var(--accent-blue);
            margin-bottom: 12px;
        }

        .warning-box {
            background: rgba(252, 129, 129, 0.1);
            border: 2px solid var(--accent-red);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .warning-box h5 {
            color: var(--accent-red);
            margin-bottom: 12px;
        }

        .inline-code {
            background: rgba(183, 148, 246, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: var(--accent-blue);
            font-size: 0.9em;
        }

        .diagram {
            text-align: center;
            padding: 20px;
            background: #1e1e1e;
            border-radius: 10px;
            margin: 20px 0;
            color: var(--accent-green);
            font-family: 'Courier New', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.8;
        }

        .flow-box {
            background: rgba(251, 211, 141, 0.1);
            border: 2px solid var(--accent-yellow);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .flow-box h5 {
            color: var(--accent-yellow);
            margin-bottom: 12px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }

            .program-title {
                font-size: 1.8em;
            }

            .container {
                padding: 20px 10px;
            }

            .program-section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>ğŸŒ SPO Vaja 10: Paralelni TCP StreÅ¾nik</h1>
        <p>TCP komunikacija z vzporednimi procesi in nitmi</p>
    </div>

    <!-- OVERVIEW -->
    <div class="program-section">
        <div class="program-title">ğŸ¯ Pregled naloge</div>

        <div class="task-box">
            <h3>NALOGA 1 â€“ PARALELNI TCP STREÅ½NIK (s procesi)</h3>
            <ul>
                <li><strong>Odjemalec (TCPclient1.c)</strong>: Ustvari N niti, vsaka nit poÅ¡lje svojo zaporedno Å¡tevilko (0 do N-1), poÄaka 5 sekund</li>
                <li><strong>StreÅ¾nik (TCPserver1.c)</strong>: Za vsako povezavo ustvari nov otroÅ¡ki proces (fork)</li>
                <li>Otrok izpiÅ¡e svoj PID, Å¡tevilko niti odjemalca, IP naslov in vrata</li>
                <li>Odjemalcu poÅ¡lje sporoÄilo - nagrado ali spodbudo (glede na PID % Å¡tevilka niti)</li>
                <li>StreÅ¾nik uporablja SIGCHLD rokovalnik, da prepreÄi zombije</li>
            </ul>
        </div>

        <div class="task-box">
            <h3>NALOGA 2 â€“ PARALELNI TCP STREÅ½NIK (z nitmi)</h3>
            <ul>
                <li><strong>StreÅ¾nik (TCPserver2.c)</strong>: Namesto fork, ustvari niti (pthread)</li>
                <li>Vsaka nit obravnava enega odjemalca</li>
                <li>Niti so detached (pthread_detach) za samodejno ÄiÅ¡Äenje</li>
                <li>Odjemalec ostane enak (TCPclient1.c)</li>
            </ul>
        </div>

        <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            NALOGA 1: FORK (procesi)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ODJEMALEC                    STREÅ½NIK          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Nit 0 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ StarÅ¡  â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”¤        â”‚          â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â”‚
â”‚  â”‚ Nit 1 â”‚â”€â”€â”€â”    â”‚              â”‚             â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”¤   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºfork()           â”‚
â”‚  â”‚ Nit 2 â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºfork()           â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”¤                        â”‚             â”‚
â”‚  â”‚  ...  â”‚                   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚ Otrok 1 â”‚       â”‚
â”‚                              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚
â”‚                              â”‚ Otrok 2 â”‚       â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          NALOGA 2: PTHREAD (niti)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ODJEMALEC                    STREÅ½NIK          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Nit 0 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ Glavna â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”¤        â”‚          â”‚  nit   â”‚        â”‚
â”‚  â”‚ Nit 1 â”‚â”€â”€â”€â”    â”‚          â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”¤   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºpthread_create() â”‚
â”‚  â”‚ Nit 2 â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºpthread_create() â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”¤                        â”‚             â”‚
â”‚  â”‚  ...  â”‚                   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚  Nit 1  â”‚       â”‚
â”‚                              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚
â”‚                              â”‚  Nit 2  â”‚       â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        </div>

        <div class="highlight-box">
            <h5>ğŸ”‘ KljuÄne razlike</h5>
            <ul>
                <li><strong>Fork</strong>: Vsak otrok je nov proces z lastnim PID-jem in pomnilniÅ¡kim prostorom</li>
                <li><strong>Pthread</strong>: Vse niti delijo isti proces in pomnilniÅ¡ki prostor</li>
                <li><strong>Fork</strong>: Potrebuje SIGCHLD rokovalnik za ÄiÅ¡Äenje zombijev</li>
                <li><strong>Pthread</strong>: Uporablja pthread_detach za samodejno ÄiÅ¡Äenje</li>
            </ul>
        </div>
    </div>

    <!-- TCPCLIENT1.C -->
    <div class="program-section">
        <div class="program-title">ğŸ’» TCPclient1.c - TCP Odjemalec z Nitmi</div>

        <div class="task-box">
            <h3>ğŸ¯ Naloga odjemalca</h3>
            <ul>
                <li>Ustvari N niti (pthread), kjer je N parameter ukazne vrstice</li>
                <li>Vsaka nit ustvari svojo TCP vtiÄnico (socket)</li>
                <li>PoÅ¡lje streÅ¾niku svojo zaporedno Å¡tevilko (0 do N-1)</li>
                <li>Prebere odgovor od streÅ¾nika in ga izpiÅ¡e</li>
                <li>ÄŒaka 5 sekund (sleep) pred zakljuÄkom</li>
            </ul>
        </div>

        <div class="code-block">
            <h4>Celotna izvorna koda:</h4>
            <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;string.h&gt;
#include &lt;arpa/inet.h&gt;

#define BUF_SIZE 256

typedef struct {
    int thread_num;
    char server_ip[16];
    int port;
} thread_data_t;

void *client_thread(void *arg)
{
    thread_data_t *data = (thread_data_t *)arg;
    int sockfd;
    struct sockaddr_in server_addr;
    char buffer[BUF_SIZE];

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket");
        pthread_exit(NULL);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(data->port);
    inet_pton(AF_INET, data->server_ip, &server_addr.sin_addr);

    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect");
        close(sockfd);
        pthread_exit(NULL);
    }

    write(sockfd, &data->thread_num, sizeof(data->thread_num));

    memset(buffer, 0, BUF_SIZE);
    read(sockfd, buffer, BUF_SIZE);
    printf("Odgovor: %s", buffer);

    sleep(5);
    close(sockfd);
    pthread_exit(NULL);
}

int main(int argc, char *argv[])
{
    if (argc != 4) {
        fprintf(stderr, "Uporaba: %s &lt;IP&gt; &lt;port&gt; &lt;N&gt;\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int N = atoi(argv[3]);
    pthread_t threads[N];
    thread_data_t data[N];

    for (int i = 0; i < N; i++) {
        data[i].thread_num = i;
        strcpy(data[i].server_ip, argv[1]);
        data[i].port = atoi(argv[2]);

        pthread_create(&threads[i], NULL, client_thread, &data[i]);
    }

    for (int i = 0; i < N; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}</code></pre>
        </div>

        <div class="explanation">
            <h4>ğŸ” Podrobna razlaga po vrsticah</h4>

            <div class="line-explanation">
                <span class="line-num">Vrstice 1-6:</span>
                <span class="code">#include &lt;stdio.h&gt;, stdlib.h, unistd.h, pthread.h, string.h, arpa/inet.h</span>
                <div class="desc">
                    <strong>VkljuÄimo potrebne knjiÅ¾nice:</strong>
                    <ul>
                        <li><code>stdio.h</code> - za printf, fprintf (vhod/izhod)</li>
                        <li><code>stdlib.h</code> - za atoi (pretvorba niza v Å¡tevilo), exit</li>
                        <li><code>unistd.h</code> - za close, sleep, write, read (POSIX sistemski klici)</li>
                        <li><code>pthread.h</code> - za pthread funkcije (ustvarjanje niti)</li>
                        <li><code>string.h</code> - za strcpy, memset (delo z nizi)</li>
                        <li><code>arpa/inet.h</code> - za TCP/IP funkcije (htons, inet_pton)</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 8:</span>
                <span class="code">#define BUF_SIZE 256</span>
                <div class="desc">
                    <strong>Definiramo velikost medpomnilnika.</strong> BUF_SIZE je konstanta, ki doloÄa, koliko bajtov lahko preberemo iz vtiÄnice (socket). 256 bajtov je dovolj za prejeta sporoÄila.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 10-14:</span>
                <span class="code">typedef struct { int thread_num; char server_ip[16]; int port; } thread_data_t;</span>
                <div class="desc">
                    <strong>Struktura za podatke, ki jih potrebuje vsaka nit:</strong>
                    <ul>
                        <li><code>thread_num</code> - zaporedna Å¡tevilka niti (0, 1, 2, ... N-1)</li>
                        <li><code>server_ip</code> - IP naslov streÅ¾nika (npr. "127.0.0.1"), 16 znakov je dovolj za IPv4</li>
                        <li><code>port</code> - Å¡tevilka vrat streÅ¾nika (npr. 8080)</li>
                    </ul>
                    Vsaka nit bo dobila kazalec na svojo kopijo te strukture.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 16:</span>
                <span class="code">void *client_thread(void *arg)</span>
                <div class="desc">
                    <strong>Funkcija, ki jo izvaja vsaka nit odjemalca.</strong>
                    <ul>
                        <li>Argument <code>arg</code> je generiÄni kazalec (void*), ki ga bomo pretvorili v thread_data_t*</li>
                        <li>Vrne void* (pthread zahteva ta podpis funkcije)</li>
                        <li>To je koda, ki se izvaja vzporedno v N nitih</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 18:</span>
                <span class="code">thread_data_t *data = (thread_data_t *)arg;</span>
                <div class="desc">
                    <strong>Pretvorimo generiÄni kazalec v pravi tip.</strong> Funkcija pthread_create nam poÅ¡lje podatke kot void*, mi pa jih pretvorimo nazaj v thread_data_t*, da lahko dostopamo do polj (thread_num, server_ip, port).
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 19-21:</span>
                <span class="code">int sockfd; struct sockaddr_in server_addr; char buffer[BUF_SIZE];</span>
                <div class="desc">
                    <strong>Lokalne spremenljivke niti:</strong>
                    <ul>
                        <li><code>sockfd</code> - deskriptor vtiÄnice (socket file descriptor), vsaka nit ima svojo vtiÄnico</li>
                        <li><code>server_addr</code> - struktura za naslov streÅ¾nika (IP + vrata)</li>
                        <li><code>buffer</code> - medpomnilnik za prejem sporoÄila od streÅ¾nika</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 23:</span>
                <span class="code">sockfd = socket(AF_INET, SOCK_STREAM, 0);</span>
                <div class="desc">
                    <strong>Ustvarimo TCP vtiÄnico.</strong>
                    <ul>
                        <li><code>AF_INET</code> - IPv4 druÅ¾ina protokolov</li>
                        <li><code>SOCK_STREAM</code> - TCP (zanesljiv, povezavno-usmerjen prenos)</li>
                        <li><code>0</code> - privzeti protokol (TCP)</li>
                        <li>Vrne deskriptor vtiÄnice ali -1 ob napaki</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 24-27:</span>
                <span class="code">if (sockfd < 0) { perror("socket"); pthread_exit(NULL); }</span>
                <div class="desc">
                    <strong>Preverjanje napak pri ustvarjanju vtiÄnice.</strong> ÄŒe socket vrne -1, izpiÅ¡emo napako s perror in konÄamo to nit s pthread_exit(NULL). Nit se zakljuÄi, ostale niti pa nadaljujejo.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 29:</span>
                <span class="code">server_addr.sin_family = AF_INET;</span>
                <div class="desc">
                    <strong>Nastavimo druÅ¾ino naslovov.</strong> sin_family = AF_INET pomeni, da bomo uporabljali IPv4 naslove.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 30:</span>
                <span class="code">server_addr.sin_port = htons(data->port);</span>
                <div class="desc">
                    <strong>Nastavimo Å¡tevilko vrat.</strong>
                    <ul>
                        <li><code>htons</code> - "host to network short" - pretvori Å¡tevilo iz raÄunalnikovega vrstnega reda bajtov v omreÅ¾nega</li>
                        <li>OmreÅ¾je uporablja "big-endian", raÄunalnik pa lahko "little-endian"</li>
                        <li>data->port je Å¡tevilka vrat (npr. 8080)</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 31:</span>
                <span class="code">inet_pton(AF_INET, data->server_ip, &server_addr.sin_addr);</span>
                <div class="desc">
                    <strong>Pretvorimo IP naslov iz tekstovne oblike v binarno.</strong>
                    <ul>
                        <li><code>inet_pton</code> - "presentation to network" - pretvori niz "127.0.0.1" v binarno strukturo</li>
                        <li><code>AF_INET</code> - IPv4 format</li>
                        <li><code>data->server_ip</code> - naslov kot niz (npr. "127.0.0.1")</li>
                        <li><code>&server_addr.sin_addr</code> - kam shranimo binarno verzijo</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 33:</span>
                <span class="code">if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)</span>
                <div class="desc">
                    <strong>PoveÅ¾emo se s streÅ¾nikom.</strong>
                    <ul>
                        <li><code>connect</code> - vzpostavi TCP povezavo s streÅ¾nikom</li>
                        <li><code>sockfd</code> - naÅ¡a vtiÄnica</li>
                        <li><code>(struct sockaddr *)&server_addr</code> - naslov streÅ¾nika (pretvorjen v generiÄni tip)</li>
                        <li><code>sizeof(server_addr)</code> - velikost strukture naslova</li>
                        <li>Vrne 0 pri uspehu, -1 ob napaki</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 34-37:</span>
                <span class="code">perror("connect"); close(sockfd); pthread_exit(NULL);</span>
                <div class="desc">
                    <strong>Obravnava napake pri povezavi.</strong> ÄŒe connect ne uspe, izpiÅ¡emo napako, zapremo vtiÄnico in konÄamo nit. To se lahko zgodi, Äe streÅ¾nik ne teÄe ali Äe je naslov napaÄen.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 39:</span>
                <span class="code">write(sockfd, &data->thread_num, sizeof(data->thread_num));</span>
                <div class="desc">
                    <strong>PoÅ¡ljemo Å¡tevilko niti streÅ¾niku.</strong>
                    <ul>
                        <li><code>write</code> - poÅ¡lje podatke preko vtiÄnice</li>
                        <li><code>sockfd</code> - naÅ¡a povezava s streÅ¾nikom</li>
                        <li><code>&data->thread_num</code> - naslov Å¡tevila (0, 1, 2, ... N-1)</li>
                        <li><code>sizeof(data->thread_num)</code> - Å¡tevilo bajtov za poslati (obiÄajno 4 bajte za int)</li>
                    </ul>
                    PoÅ¡ljemo binarno Å¡tevilo, ne niza!
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 41:</span>
                <span class="code">memset(buffer, 0, BUF_SIZE);</span>
                <div class="desc">
                    <strong>PoÄistimo medpomnilnik.</strong> memset zapolni buffer z niÄlami (0), da je pripravljen za prejem podatkov. To zagotovi, da v bufferju ni starih podatkov.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 42:</span>
                <span class="code">read(sockfd, buffer, BUF_SIZE);</span>
                <div class="desc">
                    <strong>Preberemo odgovor od streÅ¾nika.</strong>
                    <ul>
                        <li><code>read</code> - prebere podatke iz vtiÄnice</li>
                        <li><code>sockfd</code> - povezava s streÅ¾nikom</li>
                        <li><code>buffer</code> - kam shranimo prebrane podatke</li>
                        <li><code>BUF_SIZE</code> - maksimalno Å¡tevilo bajtov za prebrati</li>
                        <li>Funkcija blokira (Äaka), dokler streÅ¾nik ne poÅ¡lje podatkov</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 43:</span>
                <span class="code">printf("Odgovor: %s", buffer);</span>
                <div class="desc">
                    <strong>IzpiÅ¡emo odgovor streÅ¾nika na zaslon.</strong> Buffer vsebuje sporoÄilo od streÅ¾nika (npr. "Nit 7: Cestitam, dobili ste nagrado!"). Izpis se lahko prepleta med nitmi, ker je printf shared resource.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 45:</span>
                <span class="code">sleep(5);</span>
                <div class="desc">
                    <strong>Nit spi 5 sekund.</strong> To je zahteva naloge - vsaka nit mora Äakati 5 sekund pred zakljuÄkom. Tako je povezava odprta dovolj dolgo, da lahko streÅ¾nik tudi poÄaka in se pospravi.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 46:</span>
                <span class="code">close(sockfd);</span>
                <div class="desc">
                    <strong>Zapremo vtiÄnico.</strong> To konÄa TCP povezavo s streÅ¾nikom. StreÅ¾nik bo zaznal zaprtje in se lahko tudi zakljuÄi. Pomembno je zapreti socket, da sprostimo sistemske vire.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 47:</span>
                <span class="code">pthread_exit(NULL);</span>
                <div class="desc">
                    <strong>KonÄamo nit.</strong> pthread_exit(NULL) zakljuÄi trenutno nit. Argument NULL pomeni, da ne vraÄamo nobene vrednosti. To ni nujno na koncu funkcije, ampak je dobra praksa za jasnost.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 50:</span>
                <span class="code">int main(int argc, char *argv[])</span>
                <div class="desc">
                    <strong>Glavna funkcija programa.</strong>
                    <ul>
                        <li><code>argc</code> - Å¡tevilo argumentov ukazne vrstice</li>
                        <li><code>argv</code> - polje nizov z argumenti</li>
                        <li>argv[0] = ime programa, argv[1] = IP, argv[2] = port, argv[3] = N</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 52-55:</span>
                <span class="code">if (argc != 4) { fprintf(stderr, "Uporaba: %s &lt;IP&gt; &lt;port&gt; &lt;N&gt;\n", argv[0]); exit(EXIT_FAILURE); }</span>
                <div class="desc">
                    <strong>Preverimo pravilno uporabo programa.</strong> Program priÄakuje toÄno 4 argumente. ÄŒe jih ni, izpiÅ¡emo navodila na stderr in konÄamo program z napako. Primer pravilne uporabe: <code>./TCPclient1 127.0.0.1 8080 10</code>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 57:</span>
                <span class="code">int N = atoi(argv[3]);</span>
                <div class="desc">
                    <strong>Pretvorimo Å¡tevilo niti iz niza v Å¡tevilo.</strong> atoi ("ASCII to integer") pretvori argv[3] (npr. "10") v Å¡tevilo 10. N je Å¡tevilo niti, ki jih bomo ustvarili.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 58-59:</span>
                <span class="code">pthread_t threads[N]; thread_data_t data[N];</span>
                <div class="desc">
                    <strong>Ustvarimo polja za N niti.</strong>
                    <ul>
                        <li><code>threads[N]</code> - polje identifikatorjev niti (pthread_t)</li>
                        <li><code>data[N]</code> - polje struktur s podatki za vsako nit</li>
                        <li>To je VLA (Variable Length Array) - velikost polja je doloÄena med izvajanjem</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 61:</span>
                <span class="code">for (int i = 0; i < N; i++)</span>
                <div class="desc">
                    <strong>Zanka za ustvarjanje N niti.</strong> Spremenljivka i gre od 0 do N-1, kar so Å¡tevilke niti, ki jih bomo poslali streÅ¾niku.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 62:</span>
                <span class="code">data[i].thread_num = i;</span>
                <div class="desc">
                    <strong>Nastavimo Å¡tevilko niti.</strong> Vsaka nit bo dobila svojo edinstveno Å¡tevilko (0, 1, 2, ... N-1).
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 63:</span>
                <span class="code">strcpy(data[i].server_ip, argv[1]);</span>
                <div class="desc">
                    <strong>Skopiramo IP naslov streÅ¾nika.</strong> strcpy kopira niz argv[1] (npr. "127.0.0.1") v data[i].server_ip. Vsaka nit bo povezala na isti streÅ¾nik.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 64:</span>
                <span class="code">data[i].port = atoi(argv[2]);</span>
                <div class="desc">
                    <strong>Pretvorimo in shranimo Å¡tevilko vrat.</strong> atoi pretvori argv[2] (npr. "8080") v Å¡tevilo in ga shranimov data[i].port.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 66:</span>
                <span class="code">pthread_create(&threads[i], NULL, client_thread, &data[i]);</span>
                <div class="desc">
                    <strong>Ustvarimo novo nit.</strong>
                    <ul>
                        <li><code>&threads[i]</code> - kam shranimo identifikator nove niti</li>
                        <li><code>NULL</code> - privzeti atributi niti</li>
                        <li><code>client_thread</code> - funkcija, ki jo bo izvajala nit</li>
                        <li><code>&data[i]</code> - argument za funkcijo (kazalec na podatke i-te niti)</li>
                    </ul>
                    Nova nit zaÄne izvajati client_thread takoj.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 69-71:</span>
                <span class="code">for (int i = 0; i < N; i++) { pthread_join(threads[i], NULL); }</span>
                <div class="desc">
                    <strong>ÄŒakamo na konec vseh niti.</strong>
                    <ul>
                        <li><code>pthread_join</code> - blokira (Äaka), dokler se nit threads[i] ne konÄa</li>
                        <li><code>NULL</code> - nas ne zanima vrnjena vrednost niti</li>
                        <li>To zagotovi, da main ne konÄa programa, dokler vse niti ne konÄajo</li>
                        <li>Niti se bodo konÄale po 5 sekundah (zaradi sleep)</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 73:</span>
                <span class="code">return 0;</span>
                <div class="desc">
                    <strong>Konec programa.</strong> Vrnemo 0, kar pomeni uspeÅ¡en zakljuÄek. To se zgodi, ko se vse niti konÄajo.
                </div>
            </div>
        </div>

        <div class="flow-box">
            <h5>ğŸ“Š Potek izvajanja odjemalca</h5>
            <ol>
                <li>Program preveri argumente (IP, port, N)</li>
                <li>Ustvari N niti s pthread_create</li>
                <li>Vsaka nit:
                    <ul>
                        <li>Ustvari svojo TCP vtiÄnico</li>
                        <li>Se poveÅ¾e s streÅ¾nikom</li>
                        <li>PoÅ¡lje svojo Å¡tevilko</li>
                        <li>Prebere odgovor in ga izpiÅ¡e</li>
                        <li>Spi 5 sekund</li>
                        <li>Zapre vtiÄnico in se konÄa</li>
                    </ul>
                </li>
                <li>main Äaka, da se vse niti konÄajo (pthread_join)</li>
                <li>Program se zakljuÄi</li>
            </ol>
        </div>
    </div>


    <!-- TCPSERVER1.C -->
    <div class="program-section">
        <div class="program-title">ğŸ–¥ï¸ TCPserver1.c - TCP StreÅ¾nik z OtroÅ¡kimi Procesi (fork)</div>

        <div class="task-box">
            <h3>ğŸ¯ Naloga streÅ¾nika (NALOGA 1)</h3>
            <ul>
                <li>Ustvari TCP vtiÄnico in posluÅ¡a na doloÄenih vratih</li>
                <li>Za vsako odjemalÄevo povezavo ustvari nov otroÅ¡ki proces (fork)</li>
                <li>OtroÅ¡ki proces prejme Å¡tevilko niti in obdela zahtevo</li>
                <li>Preveri deljivost: PID otroka % Å¡tevilka niti</li>
                <li>PoÅ¡lje ustrezno sporoÄilo (nagrada ali spodbuda)</li>
                <li>Uporablja SIGCHLD rokovalnik za prepreÄevanje zombijev</li>
            </ul>
        </div>

        <div class="explanation">
            <h4>ğŸ” Razlaga po vrsticah - glej izvorno kodo TCPserver1.c</h4>
            <p>StreÅ¾nik uporablja fork() za ustvarjanje vzporednih procesov. SIGCHLD rokovalnik avtomatsko poÄisti zombije.</p>
        </div>

        <div class="flow-box">
            <h5>ğŸ“Š Potek izvajanja streÅ¾nika s fork</h5>
            <ol>
                <li>StreÅ¾nik nastavi SIGCHLD rokovalnik</li>
                <li>Ustvari vtiÄnico, jo veÅ¾e na naslov in vrata</li>
                <li>V neskonÄni zanki Äaka na povezavo (accept)</li>
                <li>fork() ustvari otroÅ¡ki proces za vsako povezavo</li>
                <li>Otrok obdela zahtevo in se zakljuÄi</li>
                <li>SIGCHLD rokovalnik poÄisti zombije</li>
            </ol>
        </div>
    </div>

    <!-- TCPSERVER2.C -->
    <div class="program-section">
        <div class="program-title">ğŸ§µ TCPserver2.c - TCP StreÅ¾nik z Nitmi (pthread)</div>

        <div class="task-box">
            <h3>ğŸ¯ Naloga streÅ¾nika (NALOGA 2)</h3>
            <ul>
                <li>Namesto fork, uporablja pthread_create za ustvarjanje niti</li>
                <li>Vsaka nit obravnava enega odjemalca</li>
                <li>Niti so detached (pthread_detach) za samodejno ÄiÅ¡Äenje</li>
                <li>Vse niti delijo isti proces in pomnilniÅ¡ki prostor</li>
                <li>Uporablja isti TID za vse odjemalce (PID glavne niti)</li>
            </ul>
        </div>

        <div class="code-block">
            <h4>Celotna izvorna koda:</h4>
            <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;

#define BACKLOG 10
#define BUF_SIZE 256

typedef struct {
    int client_fd;
    struct sockaddr_in client_addr;
} client_data_t;

void *client_handler(void *arg)
{
    client_data_t *data = (client_data_t *)arg;
    int client_fd = data->client_fd;
    struct sockaddr_in addr = data->client_addr;
    free(data);

    int thread_num;
    read(client_fd, &thread_num, sizeof(thread_num));

    char client_ip[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &addr.sin_addr, client_ip, sizeof(client_ip));
    int client_port = ntohs(addr.sin_port);

    pid_t pid = getpid();   /* PID streÅ¾nika (enak za vse niti) */
    pthread_t tid = pthread_self();

    printf("Nit streÅ¾nika (TID %lu, PID %d) streÅ¾e niti %d odjemalca (%s:%d)\n",
           tid, pid, thread_num, client_ip, client_port);

    char msg[BUF_SIZE];
    if (thread_num != 0 && pid % thread_num == 0) {
        snprintf(msg, BUF_SIZE,
                 "Nit %d: Cestitam, dobili ste nagrado!\n", thread_num);
    } else {
        snprintf(msg, BUF_SIZE,
                 "Nit %d: Vazno je sodelovati, ne zmagati.\n", thread_num);
    }

    write(client_fd, msg, strlen(msg));
    close(client_fd);

    pthread_exit(NULL);
}

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "Uporaba: %s &lt;port&gt;\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int port = atoi(argv[1]);
    int server_fd;
    struct sockaddr_in server_addr;

    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(port);

    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, BACKLOG) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    printf("TCP streÅ¾nik z nitmi posluÅ¡a na 127.0.0.1:%d\n", port);

    while (1) {
        client_data_t *data = malloc(sizeof(client_data_t));
        socklen_t len = sizeof(data->client_addr);

        data->client_fd = accept(server_fd,
                                 (struct sockaddr *)&data->client_addr,
                                 &len);

        if (data->client_fd < 0) {
            perror("accept");
            free(data);
            continue;
        }

        pthread_t tid;
        pthread_create(&tid, NULL, client_handler, data);
        pthread_detach(tid);   /* samodejno ÄiÅ¡Äenje niti */
    }

    close(server_fd);
    return 0;
}</code></pre>
        </div>

        <div class="explanation">
            <h4>ğŸ” Podrobna razlaga po vrsticah</h4>

            <div class="line-explanation">
                <span class="line-num">Vrstice 1-7:</span>
                <span class="code">#include...</span>
                <div class="desc">
                    <strong>VkljuÄimo knjiÅ¾nice.</strong> Podobno kot pri TCPserver1, ampak tu je <code>pthread.h</code> namesto <code>signal.h</code> in <code>sys/wait.h</code>, ker uporabljamo niti namesto procesov.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 12-15:</span>
                <span class="code">typedef struct { int client_fd; struct sockaddr_in client_addr; } client_data_t;</span>
                <div class="desc">
                    <strong>Struktura za podatke odjemalca.</strong> Ker moramo poslati podatke niti, jih spakitamo v strukturo:
                    <ul>
                        <li><code>client_fd</code> - deskriptor vtiÄnice za komunikacijo</li>
                        <li><code>client_addr</code> - naslov odjemalca (IP + vrata)</li>
                    </ul>
                    To strukturo alociramo z malloc in jo predamo niti.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 17:</span>
                <span class="code">void *client_handler(void *arg)</span>
                <div class="desc">
                    <strong>Funkcija, ki jo izvaja vsaka nit streÅ¾nika.</strong> To je analogno kodi otroka pri fork() - vsak odjemalec se obravnava v tej funkciji.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 19-21:</span>
                <span class="code">client_data_t *data = (client_data_t *)arg; int client_fd = data->client_fd; struct sockaddr_in addr = data->client_addr;</span>
                <div class="desc">
                    <strong>Razpakiramo podatke.</strong>
                    <ul>
                        <li>Pretvorimo void* nazaj v client_data_t*</li>
                        <li>Ekstrahiramo client_fd in client_addr v lokalne spremenljivke</li>
                        <li>To naredi kodo bolj berljivo</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 22:</span>
                <span class="code">free(data);</span>
                <div class="desc">
                    <strong>Sprostimo pomnilnik.</strong> Strukturo smo alocirali z malloc v main(), zdaj jo sprostimo v niti. Vsaka nit je odgovorna za ÄiÅ¡Äenje svojih podatkov. To MORA biti tukaj, ne v main(), ker main nadaljuje takoj (ne Äaka na nit).
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstici 24-25:</span>
                <span class="code">int thread_num; read(client_fd, &thread_num, sizeof(thread_num));</span>
                <div class="desc">
                    <strong>Preberemo Å¡tevilko niti od odjemalca.</strong> Enako kot pri TCPserver1.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 27-29:</span>
                <span class="code">char client_ip[INET_ADDRSTRLEN]; inet_ntop(...); int client_port = ntohs(...);</span>
                <div class="desc">
                    <strong>Pridobimo IP in vrata odjemalca.</strong> Pretvorimo binarni naslov v tekstovno obliko za izpis.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 31:</span>
                <span class="code">pid_t pid = getpid();</span>
                <div class="desc">
                    <strong>Dobimo PID procesa streÅ¾nika.</strong>
                    <ul>
                        <li>Pri fork() bi vsak otrok imel svoj PID</li>
                        <li>Pri pthread imajo VSE niti <strong>isti PID</strong> - to je PID glavnega procesa</li>
                        <li>To pomeni, da bo PID % thread_num vedno enak rezultat za vse niti</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 32:</span>
                <span class="code">pthread_t tid = pthread_self();</span>
                <div class="desc">
                    <strong>Dobimo TID (Thread ID) trenutne niti.</strong>
                    <ul>
                        <li><code>pthread_self()</code> - vrne identifikator trenutne niti (pthread_t)</li>
                        <li>Vsaka nit ima svoj TID (npr. 139876543210496)</li>
                        <li>To je Ğ´Ğ¾Ğ»Ğ³ Å¡tevilka (unsigned long), specifiÄna za pthread implementacijo</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstici 34-35:</span>
                <span class="code">printf("Nit streÅ¾nika (TID %lu, PID %d) streÅ¾e niti %d odjemalca (%s:%d)\n", tid, pid, thread_num, client_ip, client_port);</span>
                <div class="desc">
                    <strong>Izpis informacij.</strong>
                    <ul>
                        <li><code>%lu</code> - unsigned long za TID</li>
                        <li><code>%d</code> - int za PID</li>
                        <li>Primer izpisa: <code>Nit streÅ¾nika (TID 139876543210496, PID 1234) streÅ¾e niti 7 odjemalca (127.0.0.1:18659)</code></li>
                        <li>Opazite, da PID je enak za vse niti!</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 37-44:</span>
                <span class="code">if (thread_num != 0 && pid % thread_num == 0) { ... } else { ... }</span>
                <div class="desc">
                    <strong>Preverjanje deljivosti in sestavljanje sporoÄila.</strong>
                    <ul>
                        <li>Logika je enaka kot pri TCPserver1</li>
                        <li>AMPAK: ker je PID enak za vse niti, bo odgovor vedno enak!</li>
                        <li>ÄŒe je PID 1234 deljiv s 7, bodo VSE niti, ki dobijo thread_num 7, dobile nagrado</li>
                        <li>To je glavna razlika med fork in pthread pristopom</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstici 46-47:</span>
                <span class="code">write(client_fd, msg, strlen(msg)); close(client_fd);</span>
                <div class="desc">
                    <strong>PoÅ¡ljemo sporoÄilo in zapremo povezavo.</strong> Enako kot pri TCPserver1.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 49:</span>
                <span class="code">pthread_exit(NULL);</span>
                <div class="desc">
                    <strong>Nit se konÄa.</strong> pthread_exit zakljuÄi nit. Ker smo nit detachali, se njen pomnilnik avtomatsko sprosti.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 52-56:</span>
                <span class="code">int main(int argc, char *argv[]) { ... }</span>
                <div class="desc">
                    <strong>Glavna funkcija - preverjanje argumentov.</strong> Enako kot pri TCPserver1.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 58-86:</span>
                <span class="code">socket, setsockopt, bind, listen...</span>
                <div class="desc">
                    <strong>Nastavitev streÅ¾niÅ¡ke vtiÄnice.</strong> IdentiÄno kot pri TCPserver1 - ustvarimo socket, veÅ¾emo na naslov in vrata, nastavimo listen.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 88:</span>
                <span class="code">printf("TCP streÅ¾nik z nitmi posluÅ¡a na 127.0.0.1:%d\n", port);</span>
                <div class="desc">
                    <strong>Obvestilo, da je streÅ¾nik pripravljen.</strong>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 90:</span>
                <span class="code">while (1)</span>
                <div class="desc">
                    <strong>NeskonÄna zanka.</strong> StreÅ¾nik Äaka na povezave.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstici 91-92:</span>
                <span class="code">client_data_t *data = malloc(sizeof(client_data_t)); socklen_t len = sizeof(data->client_addr);</span>
                <div class="desc">
                    <strong>Alociramo pomnilnik za podatke odjemalca.</strong>
                    <ul>
                        <li><code>malloc</code> - alociramo na kupu (heap), ne na skladu</li>
                        <li>To je pomembno, ker mora struktura preÅ¾iveti, ko main nadaljuje v zanko</li>
                        <li>Nit bo sprostila ta pomnilnik s free(data)</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 94-96:</span>
                <span class="code">data->client_fd = accept(server_fd, (struct sockaddr *)&data->client_addr, &len);</span>
                <div class="desc">
                    <strong>ÄŒakamo na povezavo.</strong>
                    <ul>
                        <li>accept blokira, dokler se odjemalec ne poveÅ¾e</li>
                        <li>client_fd in client_addr shranimo direktno v strukturo data</li>
                        <li>To nam omogoÄi, da enostavno predamo oba podatka niti</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 98-102:</span>
                <span class="code">if (data->client_fd < 0) { perror("accept"); free(data); continue; }</span>
                <div class="desc">
                    <strong>Obravnava napake pri accept.</strong> ÄŒe accept spodleti, sprostimo alocirani pomnilnik in poskusimo znova. Ne smemo pozabiti free(data), sicer bi puÅ¡Äali pomnilnik (memory leak).
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 104:</span>
                <span class="code">pthread_t tid;</span>
                <div class="desc">
                    <strong>Spremenljivka za identifikator niti.</strong> Tukaj se shrani TID nove niti.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 105:</span>
                <span class="code">pthread_create(&tid, NULL, client_handler, data);</span>
                <div class="desc">
                    <strong>Ustvarimo novo nit.</strong>
                    <ul>
                        <li><code>&tid</code> - kam shranimo identifikator nove niti</li>
                        <li><code>NULL</code> - privzeti atributi niti</li>
                        <li><code>client_handler</code> - funkcija, ki jo bo izvajala nit</li>
                        <li><code>data</code> - argument za funkcijo (naÅ¡a struktura)</li>
                    </ul>
                    Nova nit zaÄne izvajati client_handler takoj.
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstica 106:</span>
                <span class="code">pthread_detach(tid);</span>
                <div class="desc">
                    <strong>OznaÄimo nit kot detached.</strong>
                    <ul>
                        <li>Detached nit se avtomatsko poÄisti, ko se konÄa</li>
                        <li>Ne potrebujemo pthread_join</li>
                        <li>Pomnilnik niti (stack) se avtomatsko sprosti</li>
                        <li>To je alternativa pthread_join - uporabimo eno ali drugo</li>
                        <li>Detached niti so primerne za streÅ¾nike, kjer nas ne zanima rezultat</li>
                    </ul>
                </div>
            </div>

            <div class="line-explanation">
                <span class="line-num">Vrstice 109-111:</span>
                <span class="code">close(server_fd); return 0;</span>
                <div class="desc">
                    <strong>Konec (nedosegljivo).</strong> Enako kot pri TCPserver1 - ta koda se nikoli ne izvede zaradi while(1).
                </div>
            </div>
        </div>

        <div class="flow-box">
            <h5>ğŸ“Š Potek izvajanja streÅ¾nika s pthread</h5>
            <ol>
                <li>StreÅ¾nik ustvari vtiÄnico, jo veÅ¾e na naslov in vrata</li>
                <li>V neskonÄni zanki:
                    <ul>
                        <li>accept Äaka na novo povezavo</li>
                        <li>Alociramo client_data_t na kupu (malloc)</li>
                        <li>pthread_create ustvari novo nit</li>
                        <li>pthread_detach jo oznaÄi za samodejno ÄiÅ¡Äenje</li>
                        <li>main takoj nadaljuje v zanko (ne Äaka na nit)</li>
                    </ul>
                </li>
                <li>Nit client_handler:
                    <ul>
                        <li>Sprosti pomnilnik (free(data))</li>
                        <li>Prebere thread_num</li>
                        <li>IzpiÅ¡e informacije (s TID in PID)</li>
                        <li>Preveri deljivost in poÅ¡lje sporoÄilo</li>
                        <li>Zapre vtiÄnico in se konÄa</li>
                    </ul>
                </li>
                <li>Ko se nit konÄa, se avtomatsko poÄisti (detached)</li>
            </ol>
        </div>

        <div class="highlight-box">
            <h5>ğŸ”‘ KljuÄne razlike med fork in pthread</h5>
            <table style="width: 100%; color: var(--text-secondary); margin-top: 15px;">
                <tr style="background: rgba(99, 179, 237, 0.1);">
                    <th style="padding: 10px; text-align: left;">Lastnost</th>
                    <th style="padding: 10px; text-align: left;">fork (TCPserver1)</th>
                    <th style="padding: 10px; text-align: left;">pthread (TCPserver2)</th>
                </tr>
                <tr>
                    <td style="padding: 8px;"><strong>Proces/Nit</strong></td>
                    <td style="padding: 8px;">Nov proces za vsakega odjemalca</td>
                    <td style="padding: 8px;">Nova nit za vsakega odjemalca</td>
                </tr>
                <tr style="background: rgba(99, 179, 237, 0.05);">
                    <td style="padding: 8px;"><strong>Pomnilnik</strong></td>
                    <td style="padding: 8px;">LoÄen naslovni prostor</td>
                    <td style="padding: 8px;">Deljeni naslovni prostor</td>
                </tr>
                <tr>
                    <td style="padding: 8px;"><strong>PID</strong></td>
                    <td style="padding: 8px;">Vsak otrok ima svoj PID</td>
                    <td style="padding: 8px;">Vse niti imajo isti PID</td>
                </tr>
                <tr style="background: rgba(99, 179, 237, 0.05);">
                    <td style="padding: 8px;"><strong>TID</strong></td>
                    <td style="padding: 8px;">Ni relevantno</td>
                    <td style="padding: 8px;">Vsaka nit ima svoj TID</td>
                </tr>
                <tr>
                    <td style="padding: 8px;"><strong>ÄŒiÅ¡Äenje</strong></td>
                    <td style="padding: 8px;">SIGCHLD + waitpid</td>
                    <td style="padding: 8px;">pthread_detach</td>
                </tr>
                <tr style="background: rgba(99, 179, 237, 0.05);">
                    <td style="padding: 8px;"><strong>Zombiji</strong></td>
                    <td style="padding: 8px;">MoÅ¾ni (potreben rokovalnik)</td>
                    <td style="padding: 8px;">Ne obstajajo</td>
                </tr>
                <tr>
                    <td style="padding: 8px;"><strong>Hitrost</strong></td>
                    <td style="padding: 8px;">PoÄasnejÅ¡e (fork je drag)</td>
                    <td style="padding: 8px;">HitrejÅ¡e (niti so laÅ¾je)</td>
                </tr>
                <tr style="background: rgba(99, 179, 237, 0.05);">
                    <td style="padding: 8px;"><strong>Izolacija</strong></td>
                    <td style="padding: 8px;">Popolna (procesi)</td>
                    <td style="padding: 8px;">Nobena (deljeni pomnilnik)</td>
                </tr>
                <tr>
                    <td style="padding: 8px;"><strong>Varnost</strong></td>
                    <td style="padding: 8px;">Bolj varno (izolacija)</td>
                    <td style="padding: 8px;">Manj varno (race conditions)</td>
                </tr>
            </table>
        </div>

        <div class="warning-box">
            <h5>âš ï¸ Opazka o deljivosti PID</h5>
            <p>Pri pthread verziji (TCPserver2) ima <strong>vsak odjemalec z isto Å¡tevilko niti enak odgovor</strong>, ker imajo vse niti isti PID. Pri fork verziji (TCPserver1) ima vsak odjemalec lahko razliÄen odgovor, ker ima vsak otroÅ¡ki proces svoj PID.</p>
            <p>To je ena od kljuÄnih razlik med obema pristopoma!</p>
        </div>
    </div>

    <!-- UPORABA -->
    <div class="program-section">
        <div class="program-title">ğŸš€ Kompilacija in Uporaba</div>

        <div class="code-block">
            <h4>Kompilacija:</h4>
            <pre><code class="language-bash"># Odjemalec (uporablja pthread)
gcc -o TCPclient1 TCPclient1.c -lpthread

# StreÅ¾nik 1 (uporablja fork)
gcc -o TCPserver1 TCPserver1.c

# StreÅ¾nik 2 (uporablja pthread)
gcc -o TCPserver2 TCPserver2.c -lpthread</code></pre>
        </div>

        <div class="code-block">
            <h4>Zagon - NALOGA 1 (fork):</h4>
            <pre><code class="language-bash"># Terminal 1: ZaÅ¾enemo streÅ¾nik na vratih 8080
./TCPserver1 8080

# Terminal 2: ZaÅ¾enemo odjemalca z 10 nitmi
./TCPclient1 127.0.0.1 8080 10</code></pre>
        </div>

        <div class="code-block">
            <h4>Zagon - NALOGA 2 (pthread):</h4>
            <pre><code class="language-bash"># Terminal 1: ZaÅ¾enemo streÅ¾nik na vratih 9090
./TCPserver2 9090

# Terminal 2: ZaÅ¾enemo odjemalca z 5 nitmi
./TCPclient1 127.0.0.1 9090 5</code></pre>
        </div>

        <div class="highlight-box">
            <h5>ğŸ“ Primer izhoda</h5>
            <p><strong>TCPserver1 (fork):</strong></p>
            <div class="code-snippet">StreÅ¾nik posluÅ¡a na 127.0.0.1:8080
Otrok 12345 streÅ¾nika sem stregel niti 0 odjemalca (127.0.0.1:54321)
Otrok 12346 streÅ¾nika sem stregel niti 1 odjemalca (127.0.0.1:54322)
Otrok 12347 streÅ¾nika sem stregel niti 2 odjemalca (127.0.0.1:54323)
Otrok s PID 12345 se je konÄal
Otrok s PID 12346 se je konÄal
...</div>

            <p><strong>TCPserver2 (pthread):</strong></p>
            <div class="code-snippet">TCP streÅ¾nik z nitmi posluÅ¡a na 127.0.0.1:9090
Nit streÅ¾nika (TID 140234567890123, PID 11111) streÅ¾e niti 0 odjemalca (127.0.0.1:54400)
Nit streÅ¾nika (TID 140234567890456, PID 11111) streÅ¾e niti 1 odjemalca (127.0.0.1:54401)
Nit streÅ¾nika (TID 140234567890789, PID 11111) streÅ¾e niti 2 odjemalca (127.0.0.1:54402)
...</div>

            <p><strong>TCPclient1:</strong></p>
            <div class="code-snippet">Odgovor: Nit 0: Vazno je sodelovati, ne zmagati.
Odgovor: Nit 1: Cestitam, dobili ste nagrado!
Odgovor: Nit 2: Vazno je sodelovati, ne zmagati.
...</div>
        </div>

        <div class="flow-box">
            <h5>ğŸ“ ZakljuÄek</h5>
            <p>V tej vaji smo implementirali paralelni TCP streÅ¾nik na dva naÄina:</p>
            <ul>
                <li><strong>S procesi (fork)</strong> - vsak odjemalec v svojem procesu, popolna izolacija, SIGCHLD za ÄiÅ¡Äenje</li>
                <li><strong>Z nitmi (pthread)</strong> - vse niti v istem procesu, deljeni pomnilnik, pthread_detach za ÄiÅ¡Äenje</li>
            </ul>
            <p>Obe reÅ¡itvi omogoÄata vzporedno obravnavo veÄ odjemalcev, vendar z razliÄnimi pristopi in kompromisi.</p>
        </div>
    </div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
