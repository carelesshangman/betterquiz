<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPO Vaja 4 - Buffering and Text Editor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e27;
            --bg-card: #151933;
            --text-primary: #e4e4e7;
            --text-secondary: #a1a1aa;
            --accent-purple: #b794f6;
            --accent-blue: #63b3ed;
            --accent-green: #68d391;
            --accent-orange: #f6ad55;
            --accent-red: #fc8181;
            --accent-yellow: #fbd38d;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 50px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(183, 148, 246, 0.1), rgba(99, 179, 237, 0.1));
            border-radius: 20px;
            border: 2px solid var(--accent-purple);
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.2em;
        }

        .program-section {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            border: 2px solid var(--accent-purple);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .program-title {
            font-size: 2.2em;
            color: var(--accent-blue);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .task-box {
            background: rgba(104, 211, 145, 0.1);
            border-left: 5px solid var(--accent-green);
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }

        .task-box h3 {
            color: var(--accent-green);
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .task-box ul {
            margin-left: 25px;
            color: var(--text-secondary);
        }

        .task-box li {
            margin-bottom: 10px;
            line-height: 1.8;
        }

        .code-block {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid var(--accent-purple);
            overflow-x: auto;
            position: relative;
        }

        .code-block h4 {
            color: var(--accent-purple);
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .code-block pre {
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            overflow-x: auto;
            margin: 0;
        }

        .code-block pre code {
            font-family: 'Courier New', monospace;
        }

        .explanation {
            background: rgba(183, 148, 246, 0.1);
            border-left: 5px solid var(--accent-purple);
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
        }

        .explanation h4 {
            color: var(--accent-purple);
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .explanation h5 {
            color: var(--accent-orange);
            margin: 25px 0 15px 0;
            font-size: 1.3em;
        }

        .explanation p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.9;
        }

        .explanation strong {
            color: var(--accent-orange);
        }

        .explanation ul, .explanation ol {
            margin: 15px 0 15px 30px;
        }

        .explanation li {
            margin-bottom: 12px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .code-snippet {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            color: #d4d4d4;
            border: 1px solid var(--accent-blue);
            overflow-x: auto;
        }

        .highlight-box {
            background: rgba(246, 173, 85, 0.1);
            border: 2px solid var(--accent-orange);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .highlight-box h5 {
            color: var(--accent-orange);
            margin-bottom: 12px;
        }

        .warning-box {
            background: rgba(252, 129, 129, 0.1);
            border: 2px solid var(--accent-red);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .warning-box h5 {
            color: var(--accent-red);
            margin-bottom: 12px;
        }

        .inline-code {
            background: rgba(183, 148, 246, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: var(--accent-blue);
            font-size: 0.9em;
        }

        .diagram {
            text-align: center;
            padding: 20px;
            background: #1e1e1e;
            border-radius: 10px;
            margin: 20px 0;
            color: var(--accent-green);
            font-family: 'Courier New', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.8;
        }

        .flow-box {
            background: rgba(251, 211, 141, 0.1);
            border: 2px solid var(--accent-yellow);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .flow-box h5 {
            color: var(--accent-yellow);
            margin-bottom: 12px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }

            .program-title {
                font-size: 1.8em;
            }

            .container {
                padding: 20px 10px;
            }

            .program-section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="background-animation"></div>

    <div class="docs-container">
        <a href="spo-docs-index.html" class="back-link">‚Üê Back to SPO Index</a>

        <div class="docs-header">
            <h1>üíæ Vaja 4: Buffering and Text Editor</h1>
            <p class="subtitle">Buffer optimization and line-based text editing</p>
        </div>

        <!-- program1.c -->
        <div class="file-card">
            <div class="file-name">üìÑ program1.c</div>

            <div class="task-description">
                <h3>Naloga 1: Vpliv velikosti medpomnilnika na hitrost pisanja</h3>
                <ul>
                    <li>Program uporablja razliƒçne velikosti medpomnilnika ('bufferja') pri izpisu podatkov v datoteko</li>
                    <li>S klicem funkcije fopen() ustvari dve datoteki: "izhod1" in "izhod2"</li>
                    <li>Pred pisanjem v "izhod1" nastavi velikost medpomnilnika na 10 bajtov (setvbuf)</li>
                    <li>Pred pisanjem v "izhod2" nastavi velikost medpomnilnika na 100 bajtov</li>
                    <li>V obe datoteki 5 milijon-krat izpi≈°e isti stavek</li>
                    <li>Meri ƒças zapisovanja s funkcijo time() in primerja rezultate</li>
                </ul>
            </div>

            <div class="usage-example">
                <strong>Usage Example:</strong><br>
                $ ./program1<br>
                Zacetek pisanja v izhod1.txt (buffer 10 B)...<br>
                Cas pisanja v izhod1.txt: 45.00 sekund.<br>
                Zacetek pisanja v izhod2.txt (buffer 100 B)...<br>
                Cas pisanja v izhod2.txt: 12.00 sekund.
            </div>

            <div class="code-display">
                <h4>Source Code:</h4>
                <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void) {
    FILE *f1, *f2;
    char buffer1[10];
    char buffer2[100];
    const char *stavek = "To je moj najljub≈°i stavek.\n";
    long i;
    time_t start, end;
    double cas1, cas2;

    /* --- Prva datoteka: izhod1 (buffer = 10 B) --- */
    f1 = fopen("izhod1.txt", "w");
    if (f1 == NULL) {
        perror("Napaka pri odpiranju datoteke izhod1.txt");
        return 1;
    }

    if (setvbuf(f1, buffer1, _IOFBF, sizeof(buffer1)) != 0) {
        perror("Napaka pri nastavitvi medpomnilnika za izhod1.txt");
        fclose(f1);
        return 1;
    }

    printf("Zacetek pisanja v izhod1.txt (buffer 10 B)...\n");
    start = time(NULL);
    for (i = 0; i &lt; 5000000; i++) {
        if (fputs(stavek, f1) == EOF) {
            perror("Napaka pri pisanju v izhod1.txt");
            fclose(f1);
            return 1;
        }
    }
    fflush(f1);
    end = time(NULL);
    cas1 = difftime(end, start);
    fclose(f1);
    printf("Cas pisanja v izhod1.txt: %.2f sekund.\n", cas1);

    /* --- Druga datoteka: izhod2 (buffer = 100 B) --- */
    f2 = fopen("izhod2.txt", "w");
    if (f2 == NULL) {
        perror("Napaka pri odpiranju datoteke izhod2.txt");
        return 1;
    }

    if (setvbuf(f2, buffer2, _IOFBF, sizeof(buffer2)) != 0) {
        perror("Napaka pri nastavitvi medpomnilnika za izhod2.txt");
        fclose(f2);
        return 1;
    }

    printf("Zacetek pisanja v izhod2.txt (buffer 100 B)...\n");
    start = time(NULL);
    for (i = 0; i &lt; 5000000; i++) {
        if (fputs(stavek, f2) == EOF) {
            perror("Napaka pri pisanju v izhod2.txt");
            fclose(f2);
            return 1;
        }
    }
    fflush(f2);
    end = time(NULL);
    cas2 = difftime(end, start);
    fclose(f2);
    printf("Cas pisanja v izhod2.txt: %.2f sekund.\n", cas2);

    return 0;
}</code></pre>
            </div>

            <div class="explanation-section">
                <h4>üìñ Detailed Code Explanation</h4>

                <div class="explanation-block">
                    <h5>üîß 1. Nastavitev medpomnilnika s setvbuf()</h5>
                    <div class="code-snippet">char buffer1[10];
if (setvbuf(f1, buffer1, _IOFBF, sizeof(buffer1)) != 0) {
    perror("Napaka pri nastavitvi medpomnilnika");
    return 1;
}</div>
                    <div class="description">
                        <strong>setvbuf()</strong>: Nastavi naƒçin in velikost medpomnilnika za datoteƒçni tok.<br><br>
                        <strong>Parametri:</strong>
                        <ul>
                            <li><strong>f1</strong>: FILE* kazalec na datoteƒçni tok</li>
                            <li><strong>buffer1</strong>: Na≈° buffer (lahko je tudi NULL za avtomatsko alokacijo)</li>
                            <li><strong>_IOFBF</strong>: Naƒçin medpomnjenja (Full Buffering)</li>
                            <li><strong>sizeof(buffer1)</strong>: Velikost bufferja v bajtih</li>
                        </ul>
                        <strong>Naƒçini medpomnjenja (_IOFBF, _IOLBF, _IONBF):</strong>
                        <ul>
                            <li><strong>_IOFBF</strong> (Full Buffering): Podatki se zapi≈°ejo ≈°ele ko je buffer poln</li>
                            <li><strong>_IOLBF</strong> (Line Buffering): Podatki se zapi≈°ejo ob vsakem '\n'</li>
                            <li><strong>_IONBF</strong> (No Buffering): Podatki se zapi≈°ejo takoj (brez bufferja)</li>
                        </ul>
                        <strong>Zakaj je pomembno?</strong> Sistemski klici (write) so poƒçasni. Z medpomnenjem zmanj≈°amo ≈°tevilo klicev.
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>‚è±Ô∏è 2. Merjenje ƒçasa z time() in difftime()</h5>
                    <div class="code-snippet">time_t start, end;
double cas1;

start = time(NULL);
// ... operacije ...
end = time(NULL);
cas1 = difftime(end, start);</div>
                    <div class="description">
                        <strong>time(NULL)</strong>: Vrne trenutni ƒças kot Unix timestamp (sekunde od 1.1.1970).<br><br>
                        <strong>time_t</strong>: Tip podatka za shranjevanje ƒçasa (obiƒçajno long integer).<br><br>
                        <strong>difftime(end, start)</strong>: Izraƒçuna razliko med dvema ƒçasoma v sekundah.<br>
                        ‚Üí Vrne double, kar omogoƒça decimalna mesta<br><br>
                        <strong>Zakaj difftime()?</strong> ƒåeprav bi lahko uporabili (end - start), je difftime() portabilna in deluje na vseh sistemih.
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üíæ 3. Princip delovanja bufferja</h5>
                    <div class="code-snippet">// Buffer 10B:
fputs(stavek, f1);  // Stavek dolg 29B
// ‚Üí Buffer se napolni, spro≈æi write(), buffer se izprazni
// ‚Üí Ostane ≈°e 19B za naslednji klic

// Buffer 100B:
fputs(stavek, f1);  // Stavek dolg 29B
// ‚Üí Gre v buffer (29/100 polno)
fputs(stavek, f1);  // ≈†e en stavek
// ‚Üí Gre v buffer (58/100 polno)
// ... itd. dokler ni buffer poln</div>
                    <div class="description">
                        <strong>Kako buffer vpliva na hitrost?</strong><br><br>
                        <strong>Majhen buffer (10 bajtov):</strong>
                        <ul>
                            <li>Stavek je dolg ~29 znakov</li>
                            <li>Buffer se napolni ≈æe pri vsakem klicu fputs()</li>
                            <li>Za 5M vrstic ‚Üí ~5M sistemskih klicev write()</li>
                            <li>Vsak write() zahteva preklop v kernel mode ‚Üí POƒåASNO</li>
                        </ul>
                        <strong>Veƒçji buffer (100 bajtov):</strong>
                        <ul>
                            <li>V buffer gre ~3 stavkov naenkrat</li>
                            <li>Za 5M vrstic ‚Üí ~1.7M sistemskih klicev</li>
                            <li>3x manj preklopov ‚Üí 3x HITREJ≈†E</li>
                        </ul>
                        <strong>Zakljuƒçek:</strong> Veƒçji buffer = manj sistemskih klicev = hitrej≈°e izvajanje!
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üöø 4. fflush() - roƒçno praznjenje bufferja</h5>
                    <div class="code-snippet">fflush(f1);</div>
                    <div class="description">
                        <strong>fflush()</strong>: Prisili izpis vseh podatkov iz bufferja v datoteko.<br><br>
                        <strong>Zakaj je potreben?</strong>
                        <ul>
                            <li>Buffer se avtomatsko izprazni ob fclose()</li>
                            <li>Ampak ≈æelimo meriti ƒças vkljuƒçno s pisanjem</li>
                            <li>fflush() zagotovi, da so podatki res na disku pred merjenjem konca</li>
                        </ul>
                        <strong>Kdaj uporabiti fflush()?</strong>
                        <ul>
                            <li>Pred branjem podatkov, ki smo jih pravkar pisali</li>
                            <li>Ko ≈æelimo zagotoviti, da so kritiƒçni podatki shranjeni</li>
                            <li>Pri logiranju, da vidimo sporoƒçila v realnem ƒçasu</li>
                        </ul>
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üìä 5. Praktiƒçni rezultati</h5>
                    <div class="code-snippet">// Primer meritev:
// Buffer 10B:  ~45 sekund
// Buffer 100B: ~12 sekund
// Razmerje: ~3.75x hitrej≈°e</div>
                    <div class="description">
                        <strong>Analiza rezultatov:</strong><br><br>
                        Stavek je dolg 29 bajtov (vkljuƒçno z '\n').<br><br>
                        <strong>Buffer 10B:</strong> 29B / 10B = potrebuje ~3 write klice na stavek ‚Üí 15M write klicev<br>
                        <strong>Buffer 100B:</strong> 100B / 29B = ~3.4 stavkov na write ‚Üí 1.5M write klicev<br><br>
                        <strong>Teorija:</strong> 15M / 1.5M = 10x razlika<br>
                        <strong>Praksa:</strong> ~4x razlika<br><br>
                        <strong>Zakaj manj kot teorija?</strong>
                        <ul>
                            <li>OS uporablja dodatne cache mehanizme</li>
                            <li>Disk ima svoj buffer</li>
                            <li>Overhead sistemskega klica ni edini stro≈°ek</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="key-concepts">
                <h4>Key Concepts:</h4>
                <ul>
                    <li>Buffering in vrste medpomnjenja (_IOFBF, _IOLBF, _IONBF)</li>
                    <li>setvbuf() za konfiguracijo bufferja</li>
                    <li>Vpliv velikosti bufferja na performanco</li>
                    <li>Merjenje ƒçasa z time() in difftime()</li>
                    <li>fflush() za roƒçno praznjenje bufferja</li>
                    <li>Kompromis med porabo pomnilnika in hitrostjo</li>
                </ul>
            </div>
        </div>

        <!-- kamned.c -->
        <div class="file-card">
            <div class="file-name">üìÑ kamned.c</div>

            <div class="task-description">
                <h3>Naloga 2: kamned - Preprost vrstiƒçni urejevalnik</h3>
                <ul>
                    <li>S pomoƒçjo funkcij iz knji≈ænice stdio napi≈°ite preprost vrstiƒçni urejevalnik besedil (line editor)</li>
                    <li>kamned (editor iz kamene dobe) podpira tri ukaze:</li>
                    <li><strong>-a</strong>: Doda (append) na konec datoteke vrstice, ki jih uporabnik vna≈°a</li>
                    <li><strong>-d &lt;n&gt;</strong>: Izbri≈°e (delete) n-to vrstico</li>
                    <li><strong>-i &lt;n&gt;</strong>: Vstavi (insert) n-to vrstico</li>
                    <li>Vsak ukaz izvede spremembo in zapi≈°e datoteko</li>
                </ul>
            </div>

            <div class="usage-example">
                <strong>Usage Examples:</strong><br>
                $ ./kamned test.txt -a<br>
                Vna≈°aj vrstice (prazna vrstica za konec):<br>
                Hello world<br>
                This is a test<br>
                <br>
                Vrstice dodane v test.txt.<br><br>
                $ ./kamned test.txt -d 1<br>
                Vrstica 1 izbrisana.<br><br>
                $ ./kamned test.txt -i 1<br>
                Vnesi vrstico za vstavljanje:<br>
                Nova prva vrstica<br>
                Vrstica vstavljena na mesto 1.
            </div>

            <div class="code-display">
                <h4>Source Code:</h4>
                <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX_LINE 1024
#define TEMP_FILE "temp_kamned.txt"

void append_lines(const char *filename);
void delete_line(const char *filename, int n);
void insert_line(const char *filename, int n);

int main(int argc, char *argv[]) {
    if (argc &lt; 3) {
        fprintf(stderr, "Uporaba:\n");
        fprintf(stderr, "  %s &lt;filename&gt; -a\n", argv[0]);
        fprintf(stderr, "  %s &lt;filename&gt; -d &lt;n&gt;\n", argv[0]);
        fprintf(stderr, "  %s &lt;filename&gt; -i &lt;n&gt;\n", argv[0]);
        return 1;
    }

    const char *filename = argv[1];
    const char *option = argv[2];

    if (strcmp(option, "-a") == 0) {
        append_lines(filename);
    }
    else if (strcmp(option, "-d") == 0 &amp;&amp; argc == 4) {
        int n = atoi(argv[3]);
        if (n &lt;= 0) {
            fprintf(stderr, "Neveljavna ≈°tevilka vrstice.\n");
            return 1;
        }
        delete_line(filename, n);
    }
    else if (strcmp(option, "-i") == 0 &amp;&amp; argc == 4) {
        int n = atoi(argv[3]);
        if (n &lt;= 0) {
            fprintf(stderr, "Neveljavna ≈°tevilka vrstice.\n");
            return 1;
        }
        insert_line(filename, n);
    }
    else {
        fprintf(stderr, "Neveljavna uporaba argumentov.\n");
        return 1;
    }

    return 0;
}

/* --- doda vrstice na konec datoteke --- */
void append_lines(const char *filename) {
    FILE *f = fopen(filename, "a");
    if (!f) {
        perror("Napaka pri odpiranju datoteke");
        return;
    }

    char line[MAX_LINE];
    printf("Vna≈°aj vrstice (prazna vrstica za konec):\n");
    while (1) {
        if (!fgets(line, sizeof(line), stdin)) break;
        if (strcmp(line, "\n") == 0) break;
        fputs(line, f);
    }

    fclose(f);
    printf("Vrstice dodane v %s.\n", filename);
}

/* --- izbri≈°e n-to vrstico --- */
void delete_line(const char *filename, int n) {
    FILE *f = fopen(filename, "r");
    FILE *temp = fopen(TEMP_FILE, "w");

    if (!f || !temp) {
        perror("Napaka pri odpiranju datoteke");
        if (f) fclose(f);
        if (temp) fclose(temp);
        return;
    }

    char line[MAX_LINE];
    int line_no = 0;
    int found = 0;

    while (fgets(line, sizeof(line), f)) {
        line_no++;
        if (line_no == n) {
            found = 1;
            continue; // preskoƒçi n-to vrstico
        }
        fputs(line, temp);
    }

    fclose(f);
    fclose(temp);

    if (!found) {
        printf("Vrstica %d ne obstaja.\n", n);
        remove(TEMP_FILE);
    } else {
        remove(filename);
        rename(TEMP_FILE, filename);
        printf("Vrstica %d izbrisana.\n", n);
    }
}

/* --- vstavi n-to vrstico --- */
void insert_line(const char *filename, int n) {
    FILE *f = fopen(filename, "r");
    FILE *temp = fopen(TEMP_FILE, "w");

    if (!f || !temp) {
        perror("Napaka pri odpiranju datoteke");
        if (f) fclose(f);
        if (temp) fclose(temp);
        return;
    }

    char line[MAX_LINE];
    int line_no = 0;
    int inserted = 0;

    printf("Vnesi vrstico za vstavljanje:\n");
    char new_line[MAX_LINE];
    if (!fgets(new_line, sizeof(new_line), stdin)) {
        printf("Napaka pri branju vrstice.\n");
        fclose(f);
        fclose(temp);
        remove(TEMP_FILE);
        return;
    }

    while (fgets(line, sizeof(line), f)) {
        line_no++;
        if (line_no == n) {
            fputs(new_line, temp);
            inserted = 1;
        }
        fputs(line, temp);
    }

    /* ƒåe je vstavljanje na konec */
    if (!inserted &amp;&amp; n == line_no + 1) {
        fputs(new_line, temp);
        inserted = 1;
    }

    fclose(f);
    fclose(temp);

    if (inserted) {
        remove(filename);
        rename(TEMP_FILE, filename);
        printf("Vrstica vstavljena na mesto %d.\n", n);
    } else {
        printf("Vrstica %d ne obstaja.\n", n);
        remove(TEMP_FILE);
    }
}</code></pre>
            </div>

            <div class="explanation-section">
                <h4>üìñ Detailed Code Explanation</h4>

                <div class="explanation-block">
                    <h5>‚ûï 1. Append - Dodajanje vrstic na konec</h5>
                    <div class="code-snippet">FILE *f = fopen(filename, "a");

while (1) {
    if (!fgets(line, sizeof(line), stdin)) break;
    if (strcmp(line, "\n") == 0) break;
    fputs(line, f);
}</div>
                    <div class="description">
                        <strong>fopen(filename, "a")</strong>: Odpre datoteko v naƒçinu "append".<br>
                        ‚Üí ƒåe datoteka ne obstaja, jo ustvari<br>
                        ‚Üí Vse pisanje se doda na konec obstojeƒçe vsebine<br>
                        ‚Üí Kazalec je avtomatsko na koncu datoteke<br><br>
                        <strong>fgets(line, sizeof(line), stdin)</strong>: Prebere vrstico iz standardnega vhoda.<br>
                        ‚Üí Vkljuƒçi znak '\n' na koncu<br>
                        ‚Üí Avtomatsko doda '\0' terminator<br>
                        ‚Üí Varno pred buffer overflow (max sizeof(line) znakov)<br><br>
                        <strong>Pogoj za konec:</strong> Prazna vrstica (samo '\n') konƒça vna≈°anje.
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üóëÔ∏è 2. Delete - Brisanje vrstice s pomoƒçjo zaƒçasne datoteke</h5>
                    <div class="code-snippet">FILE *f = fopen(filename, "r");
FILE *temp = fopen(TEMP_FILE, "w");

while (fgets(line, sizeof(line), f)) {
    line_no++;
    if (line_no == n) {
        found = 1;
        continue; // preskoƒçi n-to vrstico
    }
    fputs(line, temp);
}

remove(filename);
rename(TEMP_FILE, filename);</div>
                    <div class="description">
                        <strong>Algoritem "preberi-preskoƒçi-zapi≈°i":</strong><br>
                        1. Odpremo originalno datoteko za branje<br>
                        2. Ustvarimo zaƒçasno datoteko za pisanje<br>
                        3. Preberemo vrstico po vrstico<br>
                        4. Vse vrstice razen n-te prepi≈°emo v zaƒçasno<br>
                        5. Zapremo obe datoteki<br>
                        6. Izbri≈°emo original z remove()<br>
                        7. Preimenujemo zaƒçasno v original z rename()<br><br>
                        <strong>Zakaj zaƒçasna datoteka?</strong>
                        <ul>
                            <li>Ne moremo brisati iz datoteke "on-the-fly"</li>
                            <li>ƒåe bi pisali nazaj, bi prepisali naslednje vrstice</li>
                            <li>Zaƒçasna datoteka zagotavlja varnost (ƒçe program crashne, imamo ≈°e original)</li>
                        </ul>
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üìù 3. Insert - Vstavljanje vrstice</h5>
                    <div class="code-snippet">while (fgets(line, sizeof(line), f)) {
    line_no++;
    if (line_no == n) {
        fputs(new_line, temp);  // Najprej nova vrstica
        inserted = 1;
    }
    fputs(line, temp);  // Potem stara vrstica
}

// Posebej obdelamo vstavljanje na konec
if (!inserted &amp;&amp; n == line_no + 1) {
    fputs(new_line, temp);
    inserted = 1;
}</div>
                    <div class="description">
                        <strong>Vrstni red je pomemben!</strong><br><br>
                        <strong>Ko pridemo do pozicije n:</strong><br>
                        1. Najprej zapi≈°emo NOVO vrstico<br>
                        2. Nato zapi≈°emo STARO vrstico (ki je bila prej n-ta)<br>
                        ‚Üí Nova vrstica postane n-ta<br>
                        ‚Üí Stara n-ta vrstica postane (n+1)-va<br><br>
                        <strong>Primer:</strong>
                        <ul>
                            <li>Originalna datoteka: [A, B, C]</li>
                            <li>Vstavimo X na pozicijo 2</li>
                            <li>Rezultat: [A, X, B, C]</li>
                        </ul>
                        <strong>Robni primer:</strong> Vstavljanje na n = line_no + 1 (dodajanje na konec).
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üìÅ 4. Delo z zaƒçasnimi datotekami (remove in rename)</h5>
                    <div class="code-snippet">remove(filename);      // Izbri≈°e datoteko
rename(TEMP_FILE, filename);  // Preimenuje zaƒçasno v original</div>
                    <div class="description">
                        <strong>remove()</strong>: Izbri≈°e datoteko iz datoteƒçnega sistema.<br>
                        ‚Üí Deluje na zaprte datoteke<br>
                        ‚Üí Podobno kot 'rm' ukaz v Linux<br><br>
                        <strong>rename(old, new)</strong>: Preimenuje datoteko.<br>
                        ‚Üí Atomiƒçna operacija (zgodi se naenkrat)<br>
                        ‚Üí ƒåe new ≈æe obstaja, jo prepi≈°e<br>
                        ‚Üí Podobno kot 'mv' ukaz v Linux<br><br>
                        <strong>Vrstni red je pomemben!</strong><br>
                        1. Najprej remove(filename) - izbri≈°emo original<br>
                        2. Potem rename(TEMP, filename) - zaƒçasna postane nova originalna<br><br>
                        <strong>Varnostna kopija?</strong> Za produkcijske programe bi bilo pametno narediti backup pred remove().
                    </div>
                </div>

                <div class="explanation-block">
                    <h5>üîç 5. Validacija in obravnava napak</h5>
                    <div class="code-snippet">if (!f || !temp) {
    perror("Napaka pri odpiranju datoteke");
    if (f) fclose(f);
    if (temp) fclose(temp);
    return;
}

if (!found) {
    printf("Vrstica %d ne obstaja.\n", n);
    remove(TEMP_FILE);  // Pobri≈°emo zaƒçasno
}</div>
                    <div class="description">
                        <strong>Preverjanje uspe≈°nosti operacij:</strong><br><br>
                        <strong>Odpiranje datotek:</strong> Vedno preverimo, ƒçe sta f in temp razliƒçna od NULL.<br><br>
                        <strong>ƒåi≈°ƒçenje ob napaki:</strong>
                        <ul>
                            <li>Zapremo vse odprte datoteke</li>
                            <li>Izbri≈°emo zaƒçasne datoteke</li>
                            <li>Ne pustimo "smeti" v datoteƒçnem sistemu</li>
                        </ul>
                        <strong>Validacija vhodnih podatkov:</strong>
                        <ul>
                            <li>≈†tevilka vrstice mora biti &gt; 0</li>
                            <li>Preverjamo, ali vrstica res obstaja</li>
                            <li>Ustrezna sporoƒçila za uporabnika</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="key-concepts">
                <h4>Key Concepts:</h4>
                <ul>
                    <li>Branje in pisanje z fgets() in fputs()</li>
                    <li>Modi odpiranja datotek ("r", "w", "a")</li>
                    <li>Tehnika zaƒçasnih datotek za urejanje</li>
                    <li>remove() in rename() za manipulacijo datotek</li>
                    <li>Vrstiƒçno procesiranje besedilnih datotek</li>
                    <li>Validacija vnosov in obravnava napak</li>
                    <li>stdin za interaktivni vnos uporabnika</li>
                </ul>
            </div>
        </div>

    </div>

</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
</html>

